<html>
    <head>
        <title>Crystal Ball</title>
        <link rel='stylesheet' href='styles.css'>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    </head>
    <body>
        <script id="vertexShader" type="x-shader/x-vertex">
            varying vec2 fruv;

			void main()	{

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                fruv = uv;
			}

		</script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            varying vec2 fruv;

            #define PI 3.1416
            #define MAIN vec3(0, 0.039, 0.18)
            #define SEC vec3(0.827, 0.843, 0.89)

            //Noise functions from https://www.youtube.com/watch?v=zXsWftRdsvU
            float noise11(float p) {
                return fract(sin(p*633.1847) * 9827.95);
            }
                
            float noise21(vec2 p) {
                return fract(sin(p.x*827.221 + p.y*3228.8275) * 878.121);
            }

            vec2 noise22(vec2 p) {
                return fract(vec2(sin(p.x*9378.35), sin(p.y*75.589)) * 556.89);
            }

            //From https://codepen.io/Tobsta/post/procedural-generation-part-1-1d-perlin-noise
            float cosineInterpolation(float a, float b, float x) {
                float ft = x * PI;
                float f = (1. - cos(ft)) * .5;
                return a * (1. - f) + b * f;
            }

            float smoothNoise11(float p, float dist) {
                float prev = noise11(p-dist);
                float next = noise11(p+dist);
                
                return cosineInterpolation(prev, next, .5);
            }

            float smoothNoise21(vec2 uv, float cells) {
                vec2 lv = fract(uv*cells);
                vec2 id = floor(uv*cells);
                
                //smoothstep function: maybe change it later!
                lv = lv*lv*(3.-2.*lv);
                
                float bl = noise21(id);
                float br = noise21(id+vec2(1.,0.));
                float b = mix(bl, br, lv.x);
                
                float tl = noise21(id+vec2(0.,1.));
                float tr = noise21(id+vec2(1.,1.));
                float t = mix(tl, tr, lv.x);
                
                return mix(b, t, lv.y);
            }

            vec2 smoothNoise22(vec2 uv, float cells) {
                vec2 lv = fract(uv*cells);
                vec2 id = floor(uv*cells);
                
                //smoothstep function: maybe change it later!
                lv = lv*lv*(3.-2.*lv);
                
                vec2 bl = noise22(id);
                vec2 br = noise22(id+vec2(1.,0.));
                vec2 b = mix(bl, br, lv.x);
                
                vec2 tl = noise22(id+vec2(0.,1.));
                vec2 tr = noise22(id+vec2(1.,1.));
                vec2 t = mix(tl, tr, lv.x);
                
                return mix(b, t, lv.y);
            }


            float valueNoise11(float p) {
                float c = smoothNoise11(p, 0.5);
                c += smoothNoise11(p, 0.25)*.5;
                c += smoothNoise11(p, 0.125)*.25;
                c += smoothNoise11(p, 0.0625)*.125;
                
                return c /= .875;
            }

            float valueNoise21(vec2 uv) {
                float c = smoothNoise21(uv, 4.);
                c += smoothNoise21(uv, 8.)*.5;
                c += smoothNoise21(uv, 16.)*.25;
                c += smoothNoise21(uv, 32.)*.125;
                c += smoothNoise21(uv, 64.)*.0625;
                
                return c /= .9375;
            }

            vec2 valueNoise22(vec2 uv) {
                vec2 c = smoothNoise22(uv, 4.);
                c += smoothNoise22(uv, 8.)*.5;
                c += smoothNoise22(uv, 16.)*.25;
                c += smoothNoise22(uv, 32.)*.125;
                c += smoothNoise22(uv, 64.)*.0625;
                
                return c /= .9375;
            }

            void main() {
                float mix_factor = valueNoise21(fruv) - 0.5;
                vec3 col = mix(MAIN, SEC, mix_factor);
                gl_FragColor = vec4(col.x, col.y, col.z, 1);
            }
        </script>

        <script type="module">
            import * as THREE from "./three.module.js";
            import {GLTFLoader} from "./GLTFLoader.js";
            import {TrackballControls} from "./TrackballControls.js";

            let scene, camera, renderer, controls, shaderMaterial;
            
            init();
            animate();

            function init() {
                scene = new THREE.Scene();
                //scene.background = new THREE.Color(0xffffff);

                camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 100);
                camera.position.set(0, 15, 20);
                camera.lookAt(0,0,0);
                renderer = new THREE.WebGLRenderer({antialias: false});
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                const loader = new GLTFLoader();

                const geo = new THREE.BoxBufferGeometry(1,1);
                const mat = new THREE.MeshNormalMaterial();
                const test = new THREE.Mesh(geo, mat);
                //scene.add(test);

                //scene.add(new THREE.AxesHelper());

                createShaderMaterial();

                loadModels(loader);
                
                const light = new THREE.PointLight();
                light.position.set(0, 10, 0);
                scene.add(light);

                const light2 = new THREE.PointLight(0xffca2b);
                light2.position.set(-5, -5, 0);
                scene.add(light2);
                
                const light3 = new THREE.PointLight(0xff3bc1);
                light2.position.set(5, -5, 0);
                scene.add(light3);

                document.body.appendChild(renderer.domElement);
                
                controls = new TrackballControls(camera, renderer.domElement);
            }
            
            function loadModels(loader) {
                loader.load(
                    'crystal_ball/scene.gltf',
                    (gltf) => {
                        console.log('gltf', gltf);
                        const ball = gltf.scene.getObjectByName("mesh_1");
                        ball.material = shaderMaterial;
                        // Normalize ball uvs
                        const uvs = ball.geometry.attributes.uv;
                        let mx = new THREE.Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                        let mn = new THREE.Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        for (let i = 0; i < uvs.count; i++) {
                            mx = mx.max(new THREE.Vector2(uvs.getX(i), uvs.getY(i)));    
                            mn = mn.min(new THREE.Vector2(uvs.getX(i), uvs.getY(i)));    
                        }
                        //console.log('max ', mx, 'min ', mn);
                        for (let i = 0; i < uvs.count; i++) {
                            let x, y;
                            x = uvs.getX(i);
                            y = uvs.getY(i);

                            uvs.setX(i, (x - mn.x) / (mx.x - mn.x));
                            uvs.setY(i, (y - mn.y) / (mx.y - mn.y));
                        }
                        scene.add(gltf.scene);
                        /*const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
                        let i = 0;
                        gltf.scene.traverse(obj => {
                            if (obj.isMesh) {
                                console.log(obj);
                                obj.material.color = new THREE.Color(colors[i++]);
                            }
                        });*/
                        const sceneBox = new THREE.Box3().expandByObject(scene);
                        console.log('scene min and max', sceneBox.min, sceneBox.max);
                    },
                    (xhr) => {
                        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );     
                    },
                    (error) => {
                        console.error(error);
                    }
                );
            }

            function createShaderMaterial() {
                shaderMaterial = new THREE.ShaderMaterial({
                    vertexShader: $("#vertexShader").html(),
                    fragmentShader: $("#fragmentShader").html(),
                    transparent: true,
                    //lights: true
                });
            }

            function animate() {
                requestAnimationFrame(animate);

                controls.update();
                renderer.render(scene, camera);
            }

        </script>
    </body>
</html>